"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_js_1 = require("./utils.js");
/**
 * Inject the CSS compiled with JS.
 *
 * @return {Plugin}
 */
function cssInjectedByJsPlugin({ topExecutionPriority, styleId } = {
    topExecutionPriority: true,
    styleId: '',
}) {
    //Globally so we can add it to legacy and non-legacy bundle.
    let cssToInject = '';
    let config;
    return {
        apply: 'build',
        enforce: 'post',
        name: 'css-in-js-plugin',
        configResolved(_config) {
            config = _config;
        },
        generateBundle(opts, bundle) {
            return __awaiter(this, void 0, void 0, function* () {
                if (config.build.ssr) {
                    return;
                }
                const htmlFiles = Object.keys(bundle).filter((i) => i.endsWith('.html'));
                const cssAssets = Object.keys(bundle).filter((i) => bundle[i].type == 'asset' && bundle[i].fileName.endsWith('.css'));
                const jsAssets = Object.keys(bundle).filter((i) => bundle[i].type == 'chunk' &&
                    bundle[i].fileName.match(/.[cm]?js$/) != null &&
                    !bundle[i].fileName.includes('polyfill'));
                const allCssCode = cssAssets.reduce(function extractCssCodeAndDeleteFromBundle(previousValue, cssName) {
                    const cssAsset = bundle[cssName];
                    const result = previousValue + cssAsset.source;
                    delete bundle[cssName];
                    return result;
                }, '');
                if (allCssCode.length > 0) {
                    cssToInject = allCssCode;
                }
                for (const name of htmlFiles) {
                    const htmlChunk = bundle[name];
                    let replacedHtml = htmlChunk.source;
                    cssAssets.forEach((cssName) => {
                        replacedHtml = utils_js_1.removeLinkStyleSheets(replacedHtml, cssName);
                        htmlChunk.source = replacedHtml;
                    });
                }
                const jsAsset = bundle[jsAssets[0]];
                const cssInjectionCode = yield utils_js_1.buildCSSInjectionCode(cssToInject, styleId);
                const appCode = jsAsset.code;
                jsAsset.code = topExecutionPriority ? '' : appCode;
                jsAsset.code += cssInjectionCode ? cssInjectionCode.code : '';
                jsAsset.code += !topExecutionPriority ? '' : appCode;
            });
        },
    };
}
exports.default = cssInjectedByJsPlugin;
